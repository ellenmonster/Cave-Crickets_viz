---
title: "CUPN Cave Crickets Viz"
output:
  flexdashboard::flex_dashboard:
    theme: yeti
    orientation: columns
    vertical_layout: fill
runtime: shiny
---

```{r global, include=FALSE}

rm(list=ls())

### Load libraries -----
# Will automatically install any libraries it can't find
packages <- c("flexdashboard", 
              "shiny", 
              "shinyFiles", # more controlled browsing for files
              "readr",
              "janitor",
              "knitr",  
              "plotly", 
              "here",
              "tidyverse",
              "shinyWidgets", # for slider text inputs
              "gridExtra", # for arranging plots
              "magrittr",
              "RColorBrewer",
              "DT",
              "reactable", # for reactive data tables
              "htmltools", # for modifying reactable cells
              "readxl", 
              "readr",
              "shinyBS", # for hover text
              "rpart", 
              "caret", 
              "GGally",
              "rattle", #rpart tree
              "httr" # import data from web services
)

package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE, repos = "http://cran.us.r-project.org")
    library(x, character.only = TRUE)
  }
})

# Initialize rv
rv <- reactiveValues(
  dat_SS = NULL,
  dat_cov = NULL,
  df_ClustersInCommon = NULL,
  df_TotDiff = NULL,
  bar_TotDiff = NULL,
  point_TotDiff = NULL,
  df_SSDiff = NULL,
  heatplot_SSDiff = NULL,
  table_Diff = NULL
) 


```

```{r css and html}

tags$style("QuickDTMismatch {
    height: 400px; /* Set the height for this specific table */
    display: flex;
    flex-direction: column;
    justify-content: flex-start; /* Align content to the top */
  }")
  
tags$style("QuickDTMismatch .dataTables_wrapper {
    flex: 1; /* Allows the table to expand within the container */
    overflow-y: auto; /* Adds scroll only if needed */
  }")
  
tags$style("QuickDTMismatch table.dataTable {
    height: auto;
    min-height: 0;
  }")
  

# This expands maps to fill screen
tags$style("map {
           height: calc(100vh - 80px) !important;
           }")

# Add left and right margin padding on columns
tags$style(".dashboard-column {
    padding-left: 10px;
    padding-right: 10px;
}")

tags$style(".reactable {
font-size: 14px; 
}") # font size for reactable tables

# Reactable tooltip formatting
with_tooltip <- function(value, tooltip) {
  tags$abbr(style = "text-decoration: underline; text-decoration-style: dotted; cursor: help", title = tooltip, value)
}

tags$style(".scrollable-tab {
  overflow-y: scroll;
  height: calc(100vh - 100px)!important; /* Adjust based on your header/footer height */
}")

```

```{r observe}
observeEvent(eventExpr = input$dismiss_meteo_modal, {
  removeModal()
  })

observeEvent(input$cancel_import, {
    # Cancel the import
    import_in_progress(FALSE)
    showNotification("Import process canceled.", type = "warning")
  })
```

```{r functions}
### FUNCTIONS ----

FuncResetRV <- function() {
  rv$dat_SS <- NULL
    rv$dat_cov <- NULL
    rv$df_ClustersInCommon <- NULL
    rv$df_TotDiff <- NULL
    rv$bar_TotDiff <- NULL
    rv$point_TotDiff <- NULL
    rv$df_SSDiff <- NULL
    rv$heatplot_SSDiff <- NULL
    rv$table_Diff <- NULL
}

FuncImport <- function(score_files) {

  # Import and format cluster covariate data 
  FuncResetRV() # clear everything
  
  dat_cov <- read_excel(here::here("Data_in", "qryDashboardClusterCovariates.xlsx")) %>%
    dplyr::rename(EventId = EventID, SurvDate = StartDate, Entrance = LocationDescription, ClusterNotes = Comment) %>%
    dplyr::mutate(EventId = paste0("CC_", EventId),
                  SurvDate = lubridate::as_date(SurvDate),
                  ClusterId = paste(EventId, ClusterNumber, sep = "_clus")) %>%
    dplyr::group_by(ClusterId) %>%
    dplyr::mutate(StripPosMin = 10*min(BaselinePosition_meter, na.rm = TRUE)) %>% # when a cluster crosses multiple transects, keep the lowest strip position. This value is in units of transect widths (so 1/10 of a meter)
    dplyr::select(-BaselinePosition_meter) %>%
    dplyr::distinct() %>%
    dplyr::mutate(
      Proximal = StripPosMin + XminRelativeToStrip_cm/10, 
      Distal = StripPosMin + 1 + XmaxRelativeToStrip_cm/10) %>% # calculate proximal and distal ends of each cluster, in units of transect width
    dplyr::select(-XminRelativeToStrip_cm, -XmaxRelativeToStrip_cm) %>%
    dplyr::mutate(ClusterSpan = round(Distal-Proximal, 2)) %>%
    dplyr::distinct() %>%
    dplyr::select(-Proximal, -Distal)
  
  # Read in scoring data
  list_dat <- lapply(score_files, FUN = function(x) {
    scorer_name <-str_match(x, "Scores_(.*?)_")[2]
    read_csv(here::here("Data_in", x)) %>%
      clean_names("upper_camel") %>%
      dplyr::mutate(Scorer = scorer_name)
  })
    dat <- do.call(plyr::"rbind.fill", list_dat) %>%
      dplyr::rename(SurvDate = Date, ClusterNumber = ClusterN) %>%
      dplyr::mutate(
        SurvDate = lubridate::mdy(SurvDate),
        ClusterId = paste(EventId, ClusterNumber, sep = "_clus"),
        InStrip = StripPos!=-1,
        LifeStage = case_when(
          LifeStage == "A" ~ "Adult",
          LifeStage == "J" ~ "Juvenile",
          LifeStage == "UNK" ~ "UNK"),
        Sex = case_when(
          Sex == "F" ~ "Female",
          Sex == "M" ~ "Male",
          Sex == "UNK" ~ "UNK")
        ) %>%
      tidyr::replace_na(list(LifeStage = "UNK", Sex = "UNK")) %>% # for any remaining
      dplyr::mutate(StageSex = paste0(LifeStage, Sex),
                    StageSex = factor(StageSex, levels = c("AdultFemale", "AdultMale", "AdultUNK", "JuvenileUNK", "UNKUNK"))) %>%
      dplyr::select(-StripPos)
    
    common_clusters <- data.frame(table(dat$ClusterId, dat$Scorer)>0) %>%
        tibble::rownames_to_column(var = "ClusterId")
    
    return_list <- list(dat_SS = dat, dat_cov = dat_cov, df_ClustersInCommon = common_clusters)
  
    return(return_list)
    }

FuncSubDat <- function(dat_SS, common_clus, Scorer1, Scorer2, allowed_diff) {
    clusters_in_common <- common_clus$ClusterId[common_clus[Scorer1] & common_clus[Scorer2]]
  temp_diff <- dat_SS %>%
    dplyr::filter(ClusterId %in% clusters_in_common) %>%
    dplyr::mutate(Scorer=replace(Scorer, Scorer==eval(Scorer1), "Scorer1"),
                  Scorer=replace(Scorer, Scorer==eval(Scorer2), "Scorer2")) %>%
    dplyr::filter(Scorer %in% c("Scorer1", "Scorer2"))
  
  # stage match status
  stage_match <- temp_diff %>%
    dplyr::count(ClusterId, LifeStage, Scorer) %>%
    tidyr::spread(key = Scorer, value = n) %>%
    tidyr::replace_na(list(Scorer1=0, Scorer2 = 0)) %>%
    dplyr::mutate(DiffCount = Scorer2 - Scorer1) %>% 
    dplyr::select(ClusterId, DiffCount) %>% 
    group_by(ClusterId) %>% 
    dplyr::summarize(StageCountMatch = sum(abs(DiffCount))<= allowed_diff)
  
  # stage-sex diff and match status
  ss_diff <- temp_diff %>%
    dplyr::count(ClusterId, StageSex, Scorer) %>%
    tidyr::spread(key = Scorer, value = n) %>%
    tidyr::replace_na(list(Scorer1=0, Scorer2 = 0)) %>%
    dplyr::mutate(DiffCount = Scorer2 - Scorer1) %>%
    dplyr::arrange(desc(DiffCount))
  
  ss_match <- ss_diff %>% dplyr::select(ClusterId, DiffCount) %>% group_by(ClusterId) %>% dplyr::summarize(StageSexMatch = sum(abs(DiffCount))<=allowed_diff)
  
  # summary of total diffs
  tot_diff <- temp_diff %>%
    dplyr::count(ClusterId, Scorer) %>%
    tidyr::spread(key = Scorer, value = n) %>%
    tidyr::replace_na(list(Scorer1 = 0, Scorer2 = 0)) %>%
    dplyr::mutate(DiffCount = Scorer2 - Scorer1,
                  TotCountMatch = abs(DiffCount)<=allowed_diff) %>% 
    dplyr::left_join(stage_match, by = "ClusterId") %>%
    dplyr::left_join(ss_match, by = "ClusterId") %>%
    arrange(desc(DiffCount))
  
  return_list <- list(tot_diff = tot_diff, ss_diff = ss_diff)
  return(return_list)
}

# Function to create summary plots and tables of count differences 
FuncDiff <- function(dat_SS, dat_cov, common_clus, Scorer1, Scorer2) {
  sub <- FuncSubDat(dat_SS = dat_SS, common_clus = common_clus, Scorer1 = Scorer1, Scorer2 = Scorer2, allowed_diff = 0)
  
  # scatterplot of total diffs
  tot_diff_aggr <- sub$tot_diff %>%
    dplyr::count(Scorer1, Scorer2, DiffCount) %>%
    dplyr::mutate(Match = ifelse(DiffCount==0, "Counts Match", "Counts Differ"))
    
  plotly_margins <- list (l = 0, r = 0, b = 0, t = 130, pad = 4) # top margin is so title doesn't run into plotly icons

  point_tot_diff <- plot_ly(
  data = tot_diff_aggr, 
  x = ~Scorer1, 
  y = ~Scorer2, 
  type = "scatter", 
  mode = "markers",
  size = ~n,
  hovertemplate = ~paste(input$sel_Scorer1, "count:", Scorer1, "<br>", input$sel_Scorer2, "count:", Scorer2, "<br> Number of clusters: ", n),
  color = ~Match,
  colors = c("Counts Match" = "black", 
             "Counts Differ" = "orange"),
  marker = list(opacity = 0.6, sizemode = "area", sizeref = 0.5)) %>%
    layout(
      font = list(size = 12),
    margin = plotly_margins,
    legend= list(
      itemsizing="constant", # generates warnings that go away when size and color are set within marker, but doesn't work correctly that way
      orientation = "h",   # show entries horizontally
      y = 1,
      yanchor = "top",
      xanchor = "center",  # use center of legend as anchor
      x = 0.5),
    title = paste0(input$sel_Scorer2, " mismatched ", input$sel_Scorer1, " TOTAL count at\n", sum(sub$tot_diff$DiffCount!=0, na.rm = TRUE), " of ", nrow(sub$tot_diff), " clusters (", round(sum(sub$tot_diff$DiffCount!=0, na.rm = TRUE)/nrow(sub$tot_diff)*100), "%), shown as orange bubbles"),
    xaxis=list(
      title=paste(input$sel_Scorer1, "'s count of cave crickets in cluster"),
      range=c(-3, round(max(tot_diff_aggr$Scorer1, tot_diff_aggr$Scorer2, na.rm = TRUE) * 1.1)),
      constrain = "domain"),
      yaxis=list(
        title=paste(input$sel_Scorer2, "'s count of cave crickets in cluster"), 
        tickprefix = "      ",
        range=c(-3, max(tot_diff_aggr$Scorer1, tot_diff_aggr$Scorer2, na.rm = TRUE)+5), # don't set minimum to zero because zero points will be cut in half
        constrain = "domain", # constraining to domain has the yaxis min set to the range; otherwise the zeroline extends far out to the left
        scaleratio = 1, # keep aspect ratio
        scaleanchor = "x"))
  
  # bar plot of total diffs
  bar_tot_diff <- plot_ly(
    data = tot_diff_aggr %>% dplyr::group_by(DiffCount) %>% dplyr::summarise(sum_n = sum(n)), 
    x = ~DiffCount,
    y = ~sum_n,
    type="bar",
    hovertemplate = ~paste("Difference in TOTAL count:", DiffCount, "<br>Number of clusters:", sum_n),
    marker = list(
      color = "red", 
      showLegend = FALSE)) %>%
    layout(
      font = list(size = 12),
      margin = plotly_margins,
      title = paste0("Difference in total counts for cave cricket clusters ranged from ", min(tot_diff_aggr$DiffCount, na.rm = TRUE), " to ", max(tot_diff_aggr$DiffCount, na.rm = TRUE)),
      bargap = 0.01,
      xaxis=list(
        title=paste0("Difference in scorers' counts (", input$sel_Scorer2, " - ", input$sel_Scorer1, ")")),
      yaxis = list(
        title = "Number of cave cricket clusters",
        tickprefix = "      ")
      )
  
  # summary of SS diffs
  
  heat_dat_diff <- sub$ss_diff %>%
    dplyr::left_join(sub$tot_diff %>% dplyr::select(ClusterId, TotDiff = DiffCount), by = "ClusterId") %>% 
    dplyr::filter(DiffCount!=0) %>% # only keep records where stage-sex counts differed
    dplyr::mutate(ClusterId = paste0(ClusterId, "  (", TotDiff, ")")) 
  
  # heatplot of SS diffs
  heat_ss_diff <- ggplot(heat_dat_diff, aes(x = StageSex, y = ClusterId, fill = DiffCount)) +
    geom_tile(color = "gray") +
    geom_text(aes(label = DiffCount)) +
    scale_x_discrete(position = "top") +
    scale_y_discrete(limits = rev) + # reverse order of clusters on y axis, (though only gets the events in the correct order, not the clusters within events)
    scale_fill_gradient2(low = "#F0E442", high = "#CC79A7", limits=c(-6, 6), oob=scales::squish, breaks = seq(from = -6, to = 6, by = 2), name = "Difference in STAGE-SEX Count (partial legend shown)") + # oob squish condenses coloring of the more extreme values
    labs(
      title = paste0(Scorer2, " mismatched ", Scorer1, " in STAGE-SEX counts at ", length(unique(heat_dat_diff$ClusterId)), " of ", length(unique(sub$tot_diff$ClusterId)), " clusters (", round((length(unique(heat_dat_diff$ClusterId))/length(unique(sub$tot_diff$ClusterId)))*100), "%)"),
      subtitle = paste0("Negative (yellow) is ", Scorer1, "'s call, positive (purple) is ", Scorer2, "'s call\nTotal difference is in parentheses (", Scorer2, " - ", Scorer1, ")\nTop panel shows clusters with DIFFERENT TOTAL COUNTS\nBottom panel shows clusters with SAME TOTAL COUNT")) +
    theme_bw(base_size = 14) +
    facet_grid(TotDiff==0 ~ ., scales = "free", space = "free_y") +
    theme(legend.position="top",
          strip.text.y = element_blank(),
          panel.grid = element_blank(),
          plot.title = element_text(size = 18), 
          plot.subtitle = element_text( size = 16))
  
  table_dat <- sub$tot_diff %>%
    dplyr::left_join(dat_cov %>% dplyr::select(ParkCode, Entrance, SurvDate, EventId, ClusterId, ClusterCountEstimate, StripPosMin, ClusterSpan, ClusterDistance_meter, ClusterLocation, ClusterNotes, ClusterDataEntryFlag, ClusterDataEntryFlagComment), by = "ClusterId") %>%
    dplyr::select(ParkCode, Entrance, SurvDate, EventId, ClusterId, Scorer1, Scorer2, DiffCount, TotCountMatch, StageCountMatch, StageSexMatch, everything())
  
  #table 
  table_diff <- reactable(
    table_dat,
    columns = list(
      ParkCode = colDef(name = "Park Code", align = "center"),
      Entrance = colDef(name = "Cave Entrance", align = "center"),
      SurvDate = colDef(name = "Survey Date", format = colFormat(date = TRUE), align = "center"),
      EventId = colDef(name = "Event ID", align = "center"),
      ClusterId = colDef(name = "Cluster ID", align = "center"),
      Scorer1 = colDef(header = with_tooltip(paste0(input$sel_Scorer1, " Counts"), paste0(input$sel_Scorer1, "'s count of crickets for this cluster")), align = "center"),
      Scorer2 = colDef(header = with_tooltip(paste0(input$sel_Scorer2, " Counts"), paste0(input$sel_Scorer2, "'s count of crickets for this cluster")), align = "center"),
      DiffCount = colDef(header = with_tooltip(paste0("Difference in TOTAL Counts (", input$sel_Scorer2, " - ", input$sel_Scorer1, ")"), "difference in total counts between selected scorers"), align = "center"),
      TotCountMatch = colDef(header = with_tooltip("Total Counts Match?", "TRUE or FALSE, do total counts match between the scorers?"), align = "center"),
      StageCountMatch = colDef(header = with_tooltip("Lifestage Counts Match?", "TRUE or FALSE, do the counts of each lifestage (e.g., count of adults) match between the scorers?"), align = "center"),
      StageSexMatch = colDef(header = with_tooltip("Stage-Sex Counts Match?", "TRUE or FALSE, do the counts of each stage-sex class (e.g., count of adult females) match between the scorers?"), align = "center"),
      ClusterCountEstimate = colDef(header = with_tooltip("Field count", "Field estimate of # of cave crickets in cluster"), align = "center"),
      StripPosMin = colDef(header = with_tooltip("Strip position (m)", "Minimum transect location (m) along baseline"), align = "center"),
      ClusterSpan = colDef(header = with_tooltip("Cluster span", "Width of cluster along transect, in transect units"), align = "center"),
      ClusterDistance_meter = colDef(header = with_tooltip("Cluster Distance (m)", "Distance (m) from cluster to baseline"), align = "center"),
      ClusterLocation = colDef(header = with_tooltip("Cluster Location", "C = ceiling, W = wall"), align = "center"),
      ClusterNotes = colDef(name = "NOTES", align = "center"),
      ClusterDataEntryFlag = colDef(name = "Data Entry Flag", align = "center"),
      ClusterDataEntryFlagComment = colDef(name = "Data Entry Flag NOTES", align = "center")
      ),
      details = function(index) {
      data_by_cluster <- sub$ss_diff[sub$ss_diff$ClusterId == table_dat$ClusterId[index], ]
      htmltools::div(style = "padding: 50px",
                     reactable(data_by_cluster,
                               columns = list(
                                 ClusterId = colDef(show = FALSE, minWidth = 200, align = "center"),
                                 StageSex = colDef(name = "Stage-Sex Class", minWidth = 200, align = "center"),
                                 Scorer1 = colDef(header = with_tooltip(paste0(input$sel_Scorer1, "Counts"), paste0(input$sel_Scorer1, "'s count of crickets")), minWidth = 200, align = "center"),
                                 Scorer2 = colDef(header = with_tooltip(paste0(input$sel_Scorer2, "Counts"), paste0(input$sel_Scorer2, "'s count of crickets")), minWidth = 200, align = "center"),
                                 DiffCount = colDef(header = with_tooltip("# Difference in STAGE-SEX Counts", "difference in stage-sex counts between selected scorers"), minWidth = 200, align = "center")
      ),
      defaultSorted = list(StageSex = "asc"),
                               resizable = TRUE,
                               filterable = FALSE,
                               striped = FALSE,
                               highlight = TRUE,
                               showSortIcon = FALSE,
                               compact = TRUE,
                               pagination = FALSE,
                               outlined = FALSE,
                               bordered = FALSE,
  fullWidth = FALSE,
                               theme = reactableTheme(backgroundColor = "hsl(186, 56%, 94%)")
  )
  )
    },
    resizable = TRUE,
    filterable = TRUE,
    striped = FALSE,
    highlight = TRUE,
    showSortIcon = TRUE,
    compact = FALSE,
    bordered = TRUE,
    showPageSizeOptions = TRUE,
    pageSizeOptions = c(10, 15, 25, 35),
    defaultPageSize = 15)
  
  rv$df_TotDiff <- table_dat # same as sub$tot_diff but has cluster covariates added
  rv$bar_TotDiff <- bar_tot_diff
  rv$point_TotDiff <- point_tot_diff
  rv$df_SSDiff <- sub$ss_diff
  rv$heatplot_SSDiff <- heat_ss_diff 
  rv$table_Diff <- table_diff # this is a reactable
}

FuncTreeDat <- function(dat_SS, dat_cov, common_clus, Scorer1, Scorer2, allowed_diff, response) {
  sub <- FuncSubDat(dat_SS = dat_SS, common_clus = common_clus, Scorer1 = Scorer1, Scorer2 = Scorer2, allowed_diff = allowed_diff)
  
  dat_tree <- sub$tot_diff %>%
    dplyr::rename(Scorer1Count = Scorer1, Scorer2Count = Scorer2, Response = eval(response)) %>%
    dplyr::left_join(dat_cov[, c("ClusterId", "ClusterSpan", "ClusterDistance_meter", "ClusterLocation", "ClusterCountEstimate")], by = "ClusterId") %>%
    filter(complete.cases(.)) %>%
    dplyr::mutate(
      Response = ifelse(Response, "Match", "Mismatch"),
      FieldCountMatch = ifelse(abs(Scorer1Count - ClusterCountEstimate) <= allowed_diff, "Match", "Mismatch"))
  dat_tree$FieldCountMatch <- factor(dat_tree$FieldCountMatch, levels = c("Match", "Mismatch"))
  dat_tree$Response <- factor(dat_tree$Response, levels = c("Match", 
  "Mismatch")) # caret considers the first level to be the positive response
  dat_tree$Scorer2Name = Scorer2
  return(dat_tree)
  }

FuncTreeModel <- function(mod, data_train, FP_loss = 1, min_bucket) {
  set.seed(1111) #makes each code block reproducible
  cv_control <- trainControl(method="repeatedcv", number=15, repeats=10, summaryFunction=twoClassSummary, classProbs=T, savePredictions = T) 

  loss_matr <- matrix(c(0, FP_loss, 1, TN = 0), byrow = T, nrow = 2) # cost of false positives is 5X that of false negatives
  
  set.seed(1111)
  fit_rpart = caret::train(mod, data=data_train, method="rpart",  metric="ROC", trControl = cv_control, control = rpart.control(minbucket = min_bucket), parms = list(loss = loss_matr), na.action = na.pass, tuneLength = 10)
  
  return_list <- list(mod, data_train, fit_rpart)
  names(return_list) <- c("model", "data_train", "mod_rpart")
  return(return_list)
}
```

```{r action_buttons}
# (Home) Import and format new data ----
observeEvent(eventExpr = input$button_Import, {
  
  withProgress(message = "Importing and processing new data files...", detail = "you will see a pop-up message when completed",  value = 0, {
    vec_score_files = list.files(path = './Data_in', pattern = "^Scores_.*\\.csv") # identify all .csv files in the Data_in folder
    shiny::validate(need(length(vec_score_files) > 0, "No scoring data files (.csv) in the 'Data_in' folder. Please add the data files and try again."))
    
    cov_file_exists = file.exists(here::here("Data_in", "qryDashboardClusterCovariates.xlsx")) # TRUE if this file exists
    shiny::validate(need(cov_file_exists == TRUE, "Could not find a cluster covariate file (qryDashboardClusterCovariates.xlsx) in the 'Data_in' folder. Please add the covariate file and try again."))
    
    out <- FuncImport(score_files = vec_score_files)
      
        if("Surveyor" %in% names(out$dat_SS)){
    rv$dat_SS <- out$dat_SS %>% dplyr::rename(Scorer = Surveyor)
  } else {
    rv$dat_SS <- out$dat_SS
  }

    rv$dat_cov <- out$dat_cov
    rv$df_ClustersInCommon <- out$df_ClustersInCommon
    rv$df_TotDiff <- rv$bar_TotDiff <- rv$point_TotDiff <- rv$df_SSDiff <- rv$heatplot_SSDiff <- rv$table_Diff <- NULL
    
    # Save to local directory
  showModal( # Pop-up modal asking user to enter prefix to append to saved files
    modalDialog(
      textInput("out_prefix", "Prefix to append to output files: ",
                placeholder = paste0("CricketDashData_", paste0(gsub(pattern = "-", replacement = "", x = Sys.Date()))),
                value = paste0("CricketDashData_", paste0(gsub(pattern = "-", replacement = "", x = Sys.Date())))
      ),
      footer = tagList(
        actionButton("button_goSave", "SAVE"),
        actionButton("button_cancelSave", "Cancel")  # Custom cancel button with ID
      )
      

    ))
  
  observeEvent(input$button_goSave, {
    saveRDS(out, paste0("Data_out/", input$out_prefix, ".RDS"))
    
    showModal(modalDialog(
      title = "Done",
      paste0("The data for dashboard use have been saved as '", input$out_prefix, ".RDS' in the folder 'Data_out' of the current working directory, ", getwd(), ". You may now view data summaries and analysis outputs in the other dashboard pages.") 
    ))
  })
  
    observeEvent(input$button_cancelSave, {
    # If the user cancels, reset the reactive variable `rv` to NULL
    FuncResetRV()
    
    # Notify the user that the save process was canceled
    showNotification("Save process canceled.", type = "warning")
    
    # Close the modal
    removeModal()
  })
    
  })
  
  }, ignoreInit = TRUE) # end of observeEvent 
    
# (Home) Load data as RDS ----

observeEvent(eventExpr = input$button_LoadRDS, {

  showModal(modalDialog(
    fileInput("saved_data_file", label = "Import data already formatted for dashboard use ('RDS' extension)", placeholder = "Click 'Browse...' button then navigate to file", accept = c('.RDS'), width = "100%"),
    footer = tagList(
      modalButton("Cancel")
    )
  ))
})

observeEvent(eventExpr = input$saved_data_file, {
  shiny::req(!is.null(input$saved_data_file$datapath))
  
  if(!toupper(tools::file_ext(input$saved_data_file$datapath)) %in% c("RDS")) {
    showModal(modalDialog(
    title = "Error",
    "File must have .RDS extension. Please select a different file."
    ))
  } else {

    tryCatch(out <- readRDS(input$saved_data_file$datapath),
             error = function(e) {out <- NULL; print("Cannot import the selected file")})

  shiny::req(!is.null(out))
  
  if("Surveyor" %in% names(out$dat_SS)){
    rv$dat_SS <- out$dat_SS %>% dplyr::rename(Scorer = Surveyor)
  } else {
    rv$dat_SS <- out$dat_SS
  }

  rv$dat_cov <- out$dat_cov
  rv$df_ClustersInCommon <- out$df_ClustersInCommon
  rv$df_TotDiff <- rv$bar_TotDiff <- rv$point_TotDiff <- rv$df_SSDiff <- rv$heatplot_SSDiff <- rv$table_Diff <- NULL

# saveRDS(isolate(reactiveValuesToList(rv)), "TEMP_rv.RDS")
# saveRDS(isolate(reactiveValuesToList(input)), "TEMP_input.RDS")
  }

  Sys.sleep(0.25)
  showModal(modalDialog(
  title = "Done",
  "The data have been imported. You may now view data summaries and analysis outputs in the other dashboard pages."
  ))
})

# Refresh Diff Summaries ----
observeEvent(eventExpr = input$button_RefreshSummaries, {
  shiny::req(!is.null(rv$dat_SS), !is.null(rv$df_ClustersInCommon), !is.null(input$sel_Scorer1), !is.null(input$sel_Scorer2))
  
  if(input$sel_Scorer1 == input$sel_Scorer2) {
    showModal(modalDialog(
    title = "Error",
    "Cannot compare a scorer to him/herself. Scorer 1 must be different from Scorer 2."
    ))
    }
  
  shiny::req(input$sel_Scorer1 != input$sel_Scorer2)
  withProgress(message = "Generating plots", detail = "...updating plots", value = 0, {
  rv$df_TotDiff <-  rv$bar_TotDiff <- rv$point_TotDiff<- rv$df_SSDiff <-  rv$heatplot_SSDiff <- rv$table_Diff <- NULL
    
  FuncDiff(dat_SS = rv$dat_SS, dat_cov = rv$dat_cov, common_clus = rv$df_ClustersInCommon, Scorer1 = input$sel_Scorer1, Scorer2 = input$sel_Scorer2)
  Sys.sleep(1)
  })
  
})

# Generate classification tree ----

observeEvent(eventExpr = input$button_GenerateTree, {
  shiny::req(!is.null(rv$dat_SS),  !is.null(input$sel_Tree_Scorer1), !is.null(input$sel_Tree_Scorer2), !is.null(input$sel_Tree_AllowedDiff), !is.null(input$sel_Tree_ResponseMetric), !is.null(input$sel_Tree_FPloss))
  
  if(input$sel_Tree_Scorer1 == input$sel_Tree_Scorer2) {
    showModal(modalDialog(
    title = "Error",
    "Cannot compare a scorer to him/herself. Scorer 1 must be different from Scorer 2."
    ))
    }
  
  shiny::req(input$sel_Tree_Scorer1 != input$sel_Tree_Scorer2)
  withProgress(message = "Running classification model...", detail = "this may take a little bit", value = 0, {
  rv$df_Tree <- rv$list_TreeOut <- rv$mat_TestAccuracy <- NULL
  
  ### Format data and make pairs plot for classification tree analysis
if(input$sel_Tree_Scorer2 == "All") { # One scorer vs all others
  
  # format data
  list_Diff <- lapply(
    as.list(unique(rv$dat_SS$Scorer)[unique(rv$dat_SS$Scorer) != input$sel_Tree_Scorer1]),
    FUN = function(x) {FuncTreeDat(dat_SS = rv$dat_SS, dat_cov = rv$dat_cov, common_clus = rv$df_ClustersInCommon, Scorer1 = input$sel_Tree_Scorer1, Scorer2 = x, allowed_diff = input$sel_Tree_AllowedDiff, response = input$sel_Tree_ResponseMetric)}
    )
  dat_tree <- do.call("rbind", list_Diff) 
  

  
  # full model
  mod_full = as.formula("Response ~ Scorer1Count + Scorer2Name + ClusterSpan + ClusterDistance_meter + ClusterLocation + FieldCountMatch")
  
  } else { # One scorer vs another
    
    # format data
    dat_tree <- FuncTreeDat(dat_SS = rv$dat_SS, dat_cov = rv$dat_cov, common_clus = rv$df_ClustersInCommon, Scorer1 = input$sel_Tree_Scorer1, Scorer2 = input$sel_Tree_Scorer2, allowed_diff = input$sel_Tree_AllowedDiff, response = input$sel_Tree_ResponseMetric) 
    
    # full model
    mod_full = as.formula("Response ~ Scorer1Count + ClusterSpan + ClusterDistance_meter + ClusterLocation + FieldCountMatch")
  }
  
  # Make sure sufficient mismatches to continue
      if(sum(dat_tree$Response=="Mismatch") < 8) {
      showModal(modalDialog(
            title = "Not Enough Count Mismatches",
            "Need at least 8 scorer count mismatches to generate classification models. Please make another selection."
            ))}
      shiny::req(sum(dat_tree$Response=="Mismatch") >= 8)
  
  ### Split data into 70/30 train/test
  set.seed(123)
  trainset <- caret::createDataPartition(y = dat_tree$Response, p = 0.7, list = FALSE)
  data_train = dat_tree[trainset,] #extract observations/rows for training, assign to new variable
  data_test = dat_tree[-trainset,] #do the same for the test set
  
  ### Run model
  list_treeout <- FuncTreeModel(mod = mod_full, data_train = data_train, FP_loss = input$sel_Tree_FPloss, min_bucket = input$sel_MinBucket) # FP_loss means that a false positive is X times more "costly" than a false positive. False positive means that we think it's a match but it's actually a mismatch--so a higher FP_loss value means we really want to be able to find those mismatches. Matrix top row is TP (left), FP (right); bottom row is FN, TN. 
  
  ### Examine predictive accuracy of rpart model, on the TEST data
  pred = predict(list_treeout$mod_rpart, data_test)
  rv$mat_TestAccuracy <- confusionMatrix(data_test$Response, pred) # note that if FP_loss is different from 1, overall accuracy may be lower but skewing toward the less costly "mistake". Sensitivity is True Positive Rate. Specificity is True Negative Rate. So we are typically interested in getting higher specificity because it means we catch more of the mismatches.###

  dat_tree$TestTrain <- "test"
  dat_tree$TestTrain[trainset] <- "train"
  
  rv$df_Tree <- dat_tree
  rv$list_TreeOut <- list_treeout
  Sys.sleep(1)
  })
})

  
```

    
HOME
=========================================

Column {data-width=1}
-------------------------------------

Column {data-width=30}
-------------------------------------

```{r image1, echo = FALSE}
htmltools::img(src="images/Dashboard_Img_1.jpg", width = "100%", style="display:block; margin-top:10px; align:center;") # alternatively... margin-top:10px; margin-bottom:0px; margin-right:40px; margin-left:-20px"
```

```{r image2, echo = FALSE}
htmltools::img(src="images/Dashboard_Img_2.jpg", width = "100%", style="display:block; align:center;")
```


Column {data-width=2}
-------------------------------------

Column {data-width=66}
-------------------------------------

#### <font size="5">CUPN Cave Cricket Monitoring</font> 

<font size="4"> 
This dashboard is an interactive tool for visualizing cave cricket monitoring data. To begin, click one of the green buttons below to either import raw data or to load data as a formatted .RDS file. Hover over data points in maps or graphs to see summary information. All graphs can be exported as as .png files. Hover over blank area in plot titles to access added display features.”</font>

```{r}
actionButton("button_Import", "Import New Data",
             style="color:black; background-color: lightgreen; border:2px; margin:5px; width:200px; display:inline-block;")

actionButton("button_LoadRDS", "Load an Existing RDS File",
             style="color:black; background-color: lightgreen; border:2px; margin:5px; width:230px; display:inline-block;")

```

#### <font size="4">**Instructions for Importing New Data**</font>

<font size="4"> 

1.  Export (as .xlsx) the Access qry results from qryDashboardClusterCovariates and save it with the file name "qryDashboardClusterCovariates.xlsx". The file should have these required columns (case-sensitive): *EventID, StartDate, ParkCode, LocationDescription, ClusterNumber, BaselinePosition_meter, XminRelativeToStrip_cm, XmaxRelativeToStrip_cm, ClusterDistance_meter, ClusterLocation, ClusterCountEstimate, ClusterDataEntryFlag, ClusterDataEntryFlagComment, Comment* (where "EventID" is a an integer, e.g., "47"; "ClusterLocation" is recorded as "C" or "W"; and "ClusterDataEntryFlag is recorded as TRUE or FALSE)    

2.  Create scoring data files (as .csv) and save them with the file name format "Scores_xxx_yyy.csv", where "xxx" is the name assigned to a scorer and "yyy" can be any other text. An underscore is required after "Scores" and also after the scorer's name. The file must end in ".csv". An example of a valid file name is "Scores_BartSimpson_blah123blah_blah.csv". Each scoring file should have these required columns (case-sensitive): *FID, EventID, ClusterN, Date, Sex, Life_stage, Strip_Pos* (where "EventID" is a number preceded by "CC_", e.g., "CC_47"; "Sex" is recorded as "M", "F", or "U"; and "Life_stage" is recorded as "A", "J", or "U"; "Strip_Pos" is recorded as "-1" if the cricket is out-of-strip)

3.  Place all files (for import) in the "Data_in" subfolder located in the dashboard's working directory. This subfolder should include ONLY the files you want to import.

4.  In the dashboard, select the green "Import New Data" button. When data import and formatting is completed, the dashboard-ready .RDS file will be saved in the "Data_out" subfolder of the dashboard working directory. You may then proceed to the remaining dashboard pages to view data QAQC summaries and regression tree outputs.

</font>

#### <font size="4">**Instructions for Loading an Existing RDS File**</font>

<font size="4"> 

1.  In the dashboard, select the green "Import New Data" button. Browse to and select the dashboard-ready .RDS file on your computer. A pop-up window will notify you that the .RDS file is loaded. You may then proceed to the remaining dashboard pages to view data QAQC summaries and regression tree outputs.

</font> 

Column {data-width=1}
-------------------------------------

Differences in Counts Between Two Scorers
====================================== 

Inputs {.sidebar data-width=250}
-------------------------------------

```{r mainInput}  
renderUI({
  shiny::req(!is.null(rv$dat_SS))
 
  selectInput(
    "sel_Scorer1",
    label = strong("Select Scorer1 to Compare: "),
    choices = sort(unique(rv$dat_SS$Scorer)),
    selected = switch(is.null(input$sel_Scorer1)+1, input$sel_Scorer1, sort(unique(rv$dat_SS$Scorer))[1])
    )
  })

renderUI({
  shiny::req(!is.null(rv$dat_SS))
  selectInput(
    "sel_Scorer2",
    label = strong("Select Scorer2 to Compare: "),
    choices = sort(unique(rv$dat_SS$Scorer)),
    selected = switch(is.null(input$sel_Scorer2)+1, input$sel_Scorer2, sort(unique(rv$dat_SS$Scorer))[2])
    )
  })

actionButton("button_RefreshSummaries", "Refresh Summaries",
             style="color:black; background-color: lightgreen; border:2px; margin:5px; display:inline-block;")

```

Column {.tabset .tabset-fade}
-------------------------------------

### Differences in TOTAL Count
<div class="scrollable-tab">
<div style='display:flex; flex-direction:row; max-width:100%; justify-content:space-evenly; flex-wrap: wrap; align-items: center;'>

<div style='flex: 0 0 35%; border:1px solid gray; padding:5px;'>

**Pairs plot of scorer counts**
<br>
Size of point is scaled to number of data records. Hover over points for more information.
```{r}
renderPlotly({
  if(any(is.null(rv$dat_SS), is.null(rv$point_TotDiff))) {
    p_pairs <- plotly_empty(type = "scatter", mode = "markers") %>% layout(title = list(text = "No data to show", yref = "paper", y = 0.5))
    } else {
      p_pairs <- rv$point_TotDiff
    }
  
  p_pairs
})
```
</div>

<div style='flex: 0 0 60%; border:1px solid gray; padding:5px;'>

**Histogram of count differences between selected scorers**
<br>
Hover over bars for more information
```{r}
renderPlotly({
  if(any(is.null(rv$dat_SS), is.null(rv$bar_TotDiff))) {
    p_hist <- plotly_empty(type = "scatter", mode = "markers")  %>% layout(title = list(text = "No data to show", yref = "paper", y = 0.5))
    } else {
      p_hist <- rv$bar_TotDiff
    }
  
  p_hist
})
```
</div>

<div style='flex: 1 0 100%; margin-top:30px;'>

<br>
For full table with more details, see 'Table of Count Differences' tab
```{r}
div(id = "QuickDTMismatch", 
renderDataTable({
  shiny::req(!is.null(rv$df_TotDiff))
  
  quick_tab <- rv$df_TotDiff %>% 
    dplyr::filter(DiffCount != 0) %>%
    dplyr::arrange(desc(DiffCount)) %>%
    dplyr::mutate(Scorer1 = as.integer(Scorer1), Scorer2 = as.integer(Scorer2), DiffCount = as.integer(DiffCount)) %>%
    dplyr:: select(`Park Code` = ParkCode, Entrance, `Cluster ID` = ClusterId, `Scorer 1 Count` = Scorer1, `Scorer 2 Count` = Scorer2, `Difference in Counts` = DiffCount)
  

  DT::datatable(
    quick_tab,
    class="compact stripe",
    caption = htmltools::tags$caption(
      style = 'caption-side: top; text-align: center;',
      htmltools::h4("Cave cricket clusters with mismatched count totals")),
    extensions=c('Buttons'),
    options = list(
      scrollY = "100%",
      pageLength = 30,
      dom = 'Blrtip', # can remove 'f', which is the global filter
      buttons = c('copy', 'csv', 'excel'), # only exports visible page. Can set server to FALSE to default export all data, but doesn't work if data frame is large
      lengthMenu = list(c(15,30,50,-1),
                        c(15,30,50,"All"))
    )
)
})
)
```
</div>

</div>

</div>
### Matrix of Differences in Count by STAGE-SEX (only showing mismatched clusters)
<div class="scrollable-tab">
```{r}
output$out_HeatPlot <- renderPlot({
  if(any(is.null(rv$dat_SS), is.null(rv$df_SSDiff), is.null(rv$heatplot_SSDiff))) {
    p_heat <- ggplot() + labs(title = "No data to show") + theme_void(base_size = 14)
  } else {
    p_heat <- rv$heatplot_SSDiff
  }
  
  p_heat
  },
  height = reactive({switch(is.null(rv$heatplot_SSDiff)+1, 40 + length(unique(rv$heatplot_SSDiff$data$ClusterId))*20, 200)})
)
tags$style("#out_HeatPlot{height:100vh;overflow-x:scroll;overflow-y:scroll}")
plotOutput("out_HeatPlot", height="100%", width = "80%")
```
</div>
### Table of Count Differences (TOTAL and STAGE-SEX)

#### <font size="3">**For each cave cricket cluster, the main table shows the difference in TOTAL cricket counts for the selected scorers**</font>

* Hover over a column name to see column definitions

* To see summaries by STAGE-SEX for a cluster, select the black triangle to the left of the table row

```{r}
output$tab1 <- renderReactable({
  shiny::req(!is.null(rv$dat_SS), !is.null(rv$df_TotDiff), !is.null(rv$df_SSDiff), !is.null(rv$table_Diff))
  
  rv$table_Diff
})
reactableOutput("tab1")
tags$style("#tab1{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

Classification Tree Models for Count Mismatch
====================================== 

Inputs {.sidebar data-width=280}
-------------------------------------

Refer to the 'EXPLANATION OF CLASSIFICATION TREES' tab for information on classification tree models and interpreting model output. For queries with (click), click in the selection box for an explanation of the filter.

<br>
```{r treeInput} 
renderUI({
  selectInput(
    "sel_Tree_ResponseMetric",
    label = strong("Select a Response Metric: "),
    choices = c("Difference in Total Count" = "TotCountMatch", "Difference in LifeStage Count" = "StageCountMatch"),
    selected = switch(is.null(input$sel_Tree_ResponseMetric)+1, input$sel_Tree_ResponseMetric, "TotCountMatch")
    )
  })

renderUI({
  shinyBS::popify(numericInput(
    "sel_Tree_AllowedDiff",
    label = strong("'Mismatch' if Difference in Counts Exceeds (click):"),
    value = switch(is.null(input$sel_Tree_AllowedDiff)+1, input$sel_Tree_AllowedDiff, 0),
    min = 0,
    max = 5,
    step = 1
    ), title = "If the count difference between Scorer1 and Scorer2 exceeds this value, the response class for that cluster is MISMATCH for the selected response metric (total count or lifestage count)", trigger = "click", placement = "top")
}) # can't use single quotes in popover title

renderUI({
  shiny::req(!is.null(rv$dat_SS))
  selectInput(
    "sel_Tree_Scorer1",
    label = strong("Select Scorer1: "),
    choices = sort(unique(rv$dat_SS$Scorer)),
    selected = switch(is.null(input$sel_Tree_Scorer1)+1, input$sel_Tree_Scorer1, sort(unique(rv$dat_SS$Scorer))[1])
    )
  })

renderUI({
  shiny::req(!is.null(rv$dat_SS))
  shinyBS::popify(selectInput(
    "sel_Tree_Scorer2",
    label = strong("Select Scorer2 (click):"),
    choices = c(sort(unique(rv$dat_SS$Scorer)), "All"),
    selected = switch(is.null(input$sel_Tree_Scorer2)+1, input$sel_Tree_Scorer2, c(sort(unique(rv$dat_SS$Scorer)), "All")[2])
    ), title = "Selecting ALL analyzes count match/mismatch between Scorer 1 and all other scorers. In this case, Scorer2 Name is included as a predictor in classification models. Be careful when selecting ALL for Scorer2--if scorers vary greatly in the number of clusters they counted in common with Scorer1, model results will be biased toward scorers with more clusters in common (with Scorer1)", trigger = "click", placement = "top")
})

renderUI({
  shinyBS::popify(numericInput(
    "sel_Tree_FPloss",
    label = strong("Select a multiplier for the relative 'cost' of False Matches (click):"),
    value = switch(is.null(input$sel_Tree_FPloss)+1, input$sel_Tree_FPloss, 1),
    min = 1,
    max = 4,
    step = 1
    ), title = "By default, False Matches (i.e., scorer counts mismatch but the model predicts a match) are weighted equally (relative cost = 1) with False MISmatches in the classification model. The user can choose to give False Matches a greater penalty. For example, setting relative cost = 2 means that the penalty for a False Match will be twice that for a False MISmatch", trigger = "click", placement = "top")
})

renderUI({
  shinyBS::popify(numericInput(
    "sel_MinBucket",
    label = strong("What is the minimum number of observations in a node for a split to be attempted? (click)"),
    value = switch(is.null(input$sel_MinBucket)+1, input$sel_MinBucket, 3),
    min = 1,
    max = 10,
    step = 1
    ), title = "The number of training data observations in a node box must exceed this number for the node to undergo further splits", trigger = "click", placement = "top")
})

actionButton("button_GenerateTree", "Generate Classification Tree",
             style="color:black; background-color: lightgreen; border:2px; margin:5px; display:inline-block;")
```

Column {.tabset .tabset-fade}
-------------------------------------

### Final Classification Tree Model (from Training Data)

```{r}
output$out_TreePlot <- renderPlot({
  if(any(is.null(rv$dat_SS), is.null(rv$list_TreeOut))) {
    p_tree <- ggplot() + labs(title = "No data to show") + theme_void(base_size = 14)
  } else {
    p_tree <- fancyRpartPlot(rv$list_TreeOut$mod_rpart$finalModel, main = paste0("Recursive partitioning classification tree model for ", input$sel_Tree_Scorer1, " vs. ", input$sel_Tree_Scorer2, ", ", input$sel_Tree_ResponseMetric))
  } # each node shows the predicted class of the response, proportion Match (out of the number of records before that node split), and % of (total) observations in that group. The bottom row should add up to 100% of the data
  
  p_tree
  })

tags$style("#out_TreePlot{height:100vh;overflow-x:scroll;overflow-y:scroll}")
plotOutput("out_TreePlot", height="100%", width = "80%")
```

### Prediction Accuracy and Model Tuning Summaries
<div class="scrollable-tab">
<div style='display:flex; flex-direction:row; max-width:100%; justify-content:space-evenly; flex-wrap: wrap; align-items: center;'>

<div style='flex: 0 0 35%; border:1px solid gray; padding:5px;'>

**Prediction accuracy, sensitivity, and specificity (ON TEST DATA)**
<br>
In confusion matrix at top, column sums yield the predicted response classifications (match or mismatch between observer pairs) and row sums yield the observed classifications in TEST data
```{r}
renderPrint({
  shiny::req(!is.null(rv$dat_SS), !is.null(rv$mat_TestAccuracy))
  rv$mat_TestAccuracy
})
```
</div>

<div style='flex: 0 0 60%; border:1px solid gray; padding:5px;'>

**Model tuning plot (ON TRAINING DATA)** 
<br>
Relationship between model complexity parameter (cp) and ROC, with vertical red line showing cp used in final model
```{r}
renderPlotly({
  if(any(is.null(rv$dat_SS), is.null(rv$list_TreeOut), is.null(rv$list_TreeOut$mod_rpart))) {
    p_tune <- plotly_empty(type = "scatter", mode = "markers")  %>% layout(title = list(text = "No data to show", yref = "paper", y = 0.5))
  } else {
    if(nrow(rv$list_TreeOut$mod_rpart$results) ==1) {
      p_tune <- plotly_empty(type = "scatter", mode = "markers")  %>% layout(title = list(text = "No plot to show. Model tuning had only one value for model complexity parameter (cp)", yref = "paper", y = 0.5))
    } else {
      p_tune <- ggplot(rv$list_TreeOut$mod_rpart) + geom_vline(xintercept = rv$list_TreeOut$mod_rpart$bestTune$cp, color = "red", linetype = "dotted", size = 1.5) + labs(title = "ROC as a function of model complexity parameter", subtitle = "Red dotted line shows complexity parameter used in final model") + theme_bw(base_size = 12)
    }
  }
  
  p_tune

})
```
</div>

<div style='flex: 1 0 100%; margin-top:30px;'>

**Model tuning data (ON TRAINING DATA)**
<br>
Cp and ROC values correspond with model tuning plot (top right of page). Specificity and sensitivity calculations are for model on training data, so may differ from prediction summaries on test data (top left of page).
```{r}
renderTable({
  shiny::req(!is.null(rv$list_TreeOut$mod_rpart$results))
  rv$list_TreeOut$mod_rpart$results
  }, striped = TRUE, spacing = "xs", align = "c", rownames = FALSE)
```
</div>

</div>

</div>
### Table of Training and Test Data

```{r}
output$treetab <- renderReactable({
  shiny::req(!is.null(rv$dat_SS), !is.null(rv$df_Tree))
    
  reactable(
    rv$df_Tree,
    resizable = TRUE, 
    filterable = TRUE,
    striped = FALSE,
    highlight = TRUE,
    showSortIcon = TRUE,
    compact = FALSE,
    bordered = TRUE,
    showPageSizeOptions = TRUE, 
    pageSizeOptions = c(10, 15, 25, 35), 
    defaultPageSize = 15) 
})
reactableOutput("treetab")
tags$style("#treetab{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

### EXPLANATION OF CLASSIFICATION TREES

#### <font size="3">**Overview of Classification Tree Models**</font>

This dashboard runs recursive partitioning (rpart) and gradient boosted trees on the ...."Response ~ Scorer1Count + ClusterSpan + ClusterDistance_meter + ClusterLocation + FieldCountMatch". Recursive partitioning classification tree models work by repeatedly splitting training data into  subgroups (node boxes), so that the outcomes the bottom-most row of node boxes (aka the terminal 'leaf' of the tree) is made up of as homogeneous response values (Mismatch or Match between scorers, for total or lifestage count) as possible. The training data are a random 30 percent of the data, used to train the model. The final model is then applied on the test data (the remaining 70 percent of the data) to estimate model accuracy (see the 'Prediction Accuracy and Model Tuning Summaries' tab). In the final classification tree model, each node box shows:

* (top row) The majority training data response class at that node i.e., Mismatch or Match. If Mismatch, the node box is colored blue; if match, green.


* (middle row) The proportion (of prior node's data that meet the split criterion leading to the current node) with with response = Match (left side of middle row) vs. Mismatch (right side). The greater the "hit rate" (i.e., the proportion of training observations that belong to the most widely occurring response class), the better that split criterion distinguishes cave cricket clusters with matched vs. mismatched counts between scorers.

* (bottom row) The % of training data observations that actually arrive at the node (i.e., meet all split criteria leading to that node). The bottom row of node boxes adds up to approximately 100%.

For each split, the criterion is listed as a logical question (e.g., ClusterDistanceMeter >= [some number]). The branch to the left of the split (and the resulting node) represents the answer "yes" to the logical question while the branch to the right represents "no". One slightly confusing split criterion is 'FieldCountMatchMismatch < 0.5'--the "yes" branch for this criterion means that the Field Count matched Scorer 1's count of total crickets in that cluster. The way to think of this is that the predictor variable name is 'FieldCountMatch' and the criterion "Mismatch < 0.5" means the cell value for this variable is NOT 'Mismatch' (therefore it is 'Match'). Similarly, the criterion 'ClusterLocationW < 0.5' means that for the predictor variable named 'ClusterLocation' the cell value is NOT '(W)all' (therefore it is 'Ceiling', so the "yes" branch for this criterion means that the cluster was found on the cave ceiling). Field counts are not available for LifeStage Count, so are only relevant when the selected response is 'Difference in Total Count'.

See https://www.datacamp.com/community/tutorials/decision-trees-R or https://www.machinelearningplus.com/machine-learning/caret-package/ for a deeper understanding of classification tree models (including CAVEATS OF INTERPRETATION) as implemented in this dashboard


Data Tables
====================================== 

Column {.tabset .tabset-fade}
-------------------------------------

### Cave Cricket Counts

```{r}
renderDataTable({
  shiny::req(!is.null(rv$dat_SS))
  
  DT::datatable(
    rv$dat_SS %>% dplyr::select(FID = Fid, `Survey Date` = SurvDate, `Event ID` = EventId, `Cluster ID` = ClusterId, Scorer, `In Survey Strip?` = InStrip, `Life Stage` = LifeStage, Sex),
    filter = "top",
    class="compact stripe",
    caption = htmltools::tags$caption(
      style = 'caption-side: top; text-align: center;',
      htmltools::h2("Cave cricket count data, imported and formatted for summarizing in dashboard")),
    extensions=c('Buttons'),
    options = list(
      pageLength = 50,
      dom = 'Blrtip', # can remove 'f', which is the global filter
      buttons = c('copy', 'csv', 'excel'), # only exports visible page. Can set server to FALSE to default export all data, but doesn't work if data frame is large
      lengthMenu = list(c(15,30,50,-1),
                        c(15,30,50,"All"))
    )
)
})
```

### Surface Meteorological Data

```{r meteo_data_inputs}  
div(
  style = "display:flex; flex-direction:row; gap:2px; margin-left:1px; margin-right:10px",
  div(style = "flex: 1 1; width:200px;",
    actionButton("button_GetMeteo", "Import Meteorological Data",
             style="color:black; background-color: lightgreen; border:2px; margin:5px; display:inline-block;")
  ),
  
  div(
    style = "flex: 1 1; width:200px;",
          selectInput(
            "sel_meteo_station",
            label = strong("Meteorological Station"),
            choices = c("MACA_AustinH1"),
            selected = c("MACA_AustinH1")
            )
),

  div(
    style = "flex: 1 1; width:200px;",
    dateInput(
      "sel_meteo_date1", 
      label = strong("Start Date"),
      value = "2010-01-01",
      format = "yyyy-mm-dd"
      )
),

  div(
    style = "flex: 1 1; width:200px;",
    dateInput(
      "sel_meteo_date2", 
      label = strong("End Date"),
      value = Sys.Date(),
      format = "yyyy-mm-dd"
      )
  )
)

```  

```{r}
observeEvent(eventExpr = input$button_GetMeteo, { 
  shiny::req(!is.null(input$sel_meteo_station), !is.null(input$sel_meteo_date1), !is.null(input$sel_meteo_date2))
  meteo_url <- paste0("https://irma.nps.gov/aqwebportal/api/v1/export/data-set?DataSet=Air%20Temp.Austin%20Entrance%20H1%40", input$sel_meteo_station, "&Calendar=CALENDARYEAR&DateRange=EntirePeriodOfRecord&UnitID=171&Conversion=Instantaneous&IntervalPoints=PointsAsRecorded&ApprovalLevels=True&Qualifiers=False&Step=1&RoundData=False&GradeCodes=True&InterpolationTypes=False&Timezone=-6&_=1725389476748") # <<<<< This needs to be the URL for custom date range;also set it to import as .csv???

if(httr::http_status(GET(meteo_url))$category!="Success") { # make sure the service call is valid
    showModal(modalDialog(
      title = "No Surface Meterological Data",
      "Error retrieving the requested surface meteorological data from Aquarius. Please try another selection.",
      easyClose = FALSE,
      footer = tagList(
        div(style="display:inline-block; width:100px;", actionButton("dismiss_meteo_modal", "Got it!"))
        )
      )
      ) # Require user to click 'Got it!' button for the modal to close
} # Specify the file name and location where you want to save the file on your computer

  file_name <- "meteo_dat.csv"
file_path <- here::here("Data_out")

# Call the download.file() function, passing in the URL and file name/location as arguments
download.file(meteo_url, paste(file_path, file_name, sep = ""), mode = "wb")
})
```